* TODO Find out what makes an LL1 CFG.
** We are making a recognizer. 
** For our project, we will be using the LL(1) parsing algorithm.
** 
* DONE Find out how to find a valid PA set for each rule.
** For each token a in FIrst(@), add A -> @ to then entry M[A,a].
** If # is in First(@), for each element a of FOllow(A) (where a is a token or a is $), add A -> @ to M[A,a]. 
* DONE Figure out what PL/H means.
** Before we can recognize and translate PL/H, we need to define it. 
** File 9, Page 7: Bottom of page, definition for PL/H. 
* TODO Construct an LL1 CFG.
** Steps to construct an LL1 CFG.
*** Not Left Recursive
*** Unambiguous
*** Valid PA set for each rule
*** File 8, pg 9-13:
*** DONE Find Terminal Set
**** T = { * , $declare, $id, (, $int, ), ;, !, :, =, , $put, $get, $stop, $goto, $if, $do, $end, <, >,  -, /,  }
**** N = { program, decl, state, label, ustate, assign, put, get, stop, goto, if, group, logexpr, relop, expr, term, fact, var }
*** EBNF Metasymbols
**** -> - "is"
**** * - 0 or more preceding
**** + - 1 or more preceding
**** & - 1 or more preceding separated by commas
**** ! - optional occurence of preceding
**** | - alternation (i.e. "or")
**** ws (whitespace) - catenation (i.e. placing adjacent with no operator)
**** [] - grouping symbols for above
**** Precedence of Metasymbols
***** [] followed by *+&! followed by catenation followed by | 

*** DONE Prove that the EBNF which is the definition of the PL/H is left recursive first, and thus not an LL1 CFG.
*** DONE Change EBNF To a CFG.
**** program -> decls states
**** decls -> decl decls 
**** decls -> # 
**** states -> state states
**** states -> #
**** decl -> '$declare' idlist
**** idlist -> '$id' '('  '$int'  ')' melist
**** melist -> ',' '$id' '('  '$int'  ')'  melist
**** melist -> #
**** state -> labelsub ustate
**** labelsub -> label
**** labelsub -> #
**** label -> ':' '$id' ':' 
**** ustate -> assign  
**** ustate -> put 
**** ustate -> get 
**** ustate -> stop 
**** ustate -> goto 
**** ustate -> if 
**** ustate -> group 
**** assign -> var '=' expr ';' 
**** put -> '$put' exprlist ';'
**** exprlist -> expr mexprs 
**** mexprs -> ',' expr mexprs
**** mexprs -> # 
**** get -> '$get' varlist ';' 
**** varlist -> var mvar
**** mvar -> ',' var mvar 
**** mvar -> # 
**** stop -> '$stop' ';' 
**** goto -> '$goto' '$id' ';' 
**** if -> '$if' logexpr '$then' state 
**** group -> '$do' ';' states '$end' ';'
**** logexpr -> expr relop expr  
**** relop ->  '<'
**** relop -> '>'  
**** relop -> '=' 
**** relop -> '<' '=' 
**** relop -> '>' '=' 
**** relop -> '<' '>' 
**** expr -> plusminsub term plusminterms
**** plusminsub -> '+'
**** plusminsub -> '-'
**** plusminsub -> #
**** plusminterms ->  '+' term plusminterms
**** plusminterms -> '-' term plusminterms
**** plusminterms -> # 
**** term -> fact muldiv 
**** muldiv -> '*' fact muldiv
**** muldiv -> '/' fact muldiv 
**** muldiv -> # 
**** fact -> var 
**** fact -> '$int' 
**** fact -> '(' expr ')' 
**** var -> '$id'  sub
**** sub -> '(' expr ')'  
**** sub -> # 
*** DONE Get First sets for all the rules
**** First(program) ={ '$declare', # }
**** First(decls) = { '$declare', # }
**** First(states) = { ':', # } 
**** First(decl) = { '$declare' } 
**** First(idlist) = { '$id' } 
**** First(melist) = { ' , ' , # }  
**** First(state) = { ' : ', #  }
**** First(labelsub) = { ' : ' , # }   
**** First(label) = { ' : ' }
**** First(ustate) = { '$id', '$put', '$get', '$stop', '$goto', '$if', '$do' } 
**** First(assign) = { '$id' } 
**** First(put) = { '$put' }
**** First(exprlist) = { '+', '-', # } 
**** First(mexprs) = { ' , ' , # } 
**** First(get) = { '$get' }
**** First(varlist) = { '$id' }  
**** First(mvar) = { ' , ' , # }   
**** First(stop) = { '$stop' } 
**** First(goto) = { '$goto' }  
**** First(if) = { '$if ' } 
**** First(group) = { '$do' }  
**** First(logexpr) = { '+', '-', # } 
**** First(relop) = { '<', '>', '<' '='', '>' '=', '<' '>' }
**** First(expr) = { '+', '-', # }
**** First(plusminsub) = { '+', '-', # } 
**** First(plusminterms) = { '+', '-', # }
**** First(term) = { '$id' } 
**** First(muldiv) = { ' * ', '/ ' , # } 
**** First(fact) = { '$id', $int, '(' }  
**** First(var) = {'$id'} 
**** First(sub) = { '(', # } 
*** TODO Get Follow sets for all the rules
**** Follow(program) = { # }
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
**** Follow(
*** TODO Get Selection sets for all the rules
*** TODO After proving EBNF is not Left Recursive, convert CFG to be not left recursive by either left factoring or eliminating left recursion.
*** TODO Generate A valid PA set for each rule.
**** TODO: Create First and Follow Sets for each rule.
*** TODO Import the CFG and PA sets into Parse.cpp so as to create a recognizer for PL/H.
*** TODO Test this recognizer by taking TokeFile.txt to be SelectionSortTokeFile.txt and running your recognizer with ParseTrace and SendOutputToFile both on.








