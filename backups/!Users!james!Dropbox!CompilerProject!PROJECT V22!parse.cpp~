/* parser  - Dev-CPP 5 version

same as previous parse.cpp except actions symbols are embedded
in rules in userule fcn so that it will produce a translation.


WHEN USED AS A PARSER:
Read terminals from tokfile, which is created either through text editing or
running scanner, and output accept/reject and optionally a derivation.

The parser is based on a CFG whose rule and parse action table are encoded
procedurally in the function 'userule'. There is a restriction on the names
of the alphabet symbols: non-terminals must begin with a letter, actions
with a digit, and terminals with anything else.  Also, the CFG goal symbol
must be literally 'goal'.  The parser is initialized to the following CFG:
   goal -> e
   e -> t mt
   mt -> '+ t mt
   mt ->
   t -> f mf
   mf -> '*' f mf
   mf ->
   f -> '$id'
   f -> '(' e ')'

The subject string to be parsed should be put in tokfile as follows: each
terminal symbol occupies 1 odd-numbered line, left-justified, with
optionally trailing blanks;  the even numbered lines following these each
contain blanks or are empty.  e.g.  to parse $id + $id   tokfile should be
$id<eol><eol>+<eol><eol>$id<eol><eol>

This program contains data structures and procedures that will later be
used for translation; they can be ignored when using as a parser.

WHEN USED AS A TRANSLATOR:
Read tokens from tokfile, which is created either through text editing or
running scanner, output accept/reject and optionally a derivation, and
output the corresponding codefile and datafile for later input by simul.cpp .

The translator is based on a translation CFG whose rule and parse action
table are encoded procedurally in the procedure userule and whose action
symbols are defined in the procedure doaction.  The same alphabet
restrictions apply as when used as a parser.  To emit code for simple
expressions, the CFG above should be changed to:
   goal -> e
   e -> t mt
   mt -> + 1 t mt
   mt ->
   t -> f mf
   mf -> * 2 f mf
   mf ->
   f -> $id 3
   f -> ( e )

The subject string to be translated should be put in tokfile as follows:
each terminal symbol/token name occupies 1 odd numbered line, left-
justified, with optionally trailing blanks;  the even numbered lines
following these each contain the corresponding token value, left-justified,
with optionally trailing blanks.  e.g.  to translate
($id,xmax) (+,empty) ($id,ymax)   tokfile should be
$id<eol>xmax<eol>+<eol><eol>$id<eol>ymax<eol>
*/


/* include files */
#include <stdio.h>
#include <curses.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

/* constants */
#define  CODE_SIZE  1000
#define  DATA_SIZE  1000
#define  STACK_SIZE  1000
#define  STR_SIZE  80
   /* maximum number of characters, not including NULL, in strings
   of our standard string type 'str' */
char strfield[]="%s";  /* for input into variables of type str */
//int true=1;  //uncomment for a C compiler
//int false=0;
char emptystr[STR_SIZE+1]="";
int fw=5;  /* standard field width for output */
int parse_error=1;
   /* to be returned by exit when parser hits bug */

/* types */
typedef char str[STR_SIZE+1];
   /* our standard string type.  allocates storage */
/* typedef char *strparam; */
typedef char strparam[];
   /* type for formal parameter strings.  doesn't allocate storage */
//typedef int bool;  //uncomment for a C compiler

/* variables */
str stack[STACK_SIZE];   /* parse stack */
int top;
   /* always indexes top of stack.  top=0 indicates stack is empty */
FILE *tokfilep;
   /* pointer to tokfile, file of tokens to be read by scanner.
      each token is two lines of this file.
   */
str tokname,tokvalue;
  /* store 'next' token.  function gettok reads into these from tokfile */
str code[CODE_SIZE];
   /* image of code memory.  will be filled by parser */
int pc;  /* indexes last word emitted into code memory */
int data[DATA_SIZE];  /* image of data memory.  will be filled by parser */
int dc;  /* indexes last word emitted into data memory */
FILE *codefilep, *datafilep;
   /*  pointers to codefile and datafile.  code and data arrays will be
   written to these files at end of parser execution.
   */
bool parsetrace=true;
   /* determines whether parser will produce a trace */
bool SendOutputToFile=false;
  //when true, standard output is redirected to a text file
FILE *outfilep;  //file pointer for redirected output

/* function prototypes */
void cycle(void);
void userule(bool *successp);
void doaction(void);
void emit(strparam s);
void initialize(void);
void cleanup(void);
void parsepic(void);
void replace(strparam rightpart);
void pushstring(strparam rightpart);
void pop(void);
void push_substring_as_one_element(strparam s, int l, int r);
int smaller_int_of(int n, int m);
void push(strparam s);
bool ontop(strparam s);
char *topstack(void);
void gettok(void);
bool athead(strparam s);
char *nextinput(void);
bool is_action(strparam s);
bool is_nonterm(strparam s);
bool eqstr(strparam s1, strparam s2);
void increment_num_lines_printed(int extra_lines);

/*
Note:
i=atoi("-123"); leaves -123 in int variable i.
sprintf(s, "%d", -123); leaves "-123" in string variable s.
atoi is in stdlib.h, and sprintf is in stdio.h.
*/

/*************************************************************************/
int main(void)
{
parsetrace=true;
SendOutputToFile=true;
initialize();
cycle();
cleanup();
end: puts("parser done");
if (!SendOutputToFile)
   {
      puts("push Enter to leave User Window");  /* for Turbo C++ */
      getchar();
   }
exit(0);
}  /* end main */
/*************************************************************************/
void cycle(void)
/*
main cycle of parser
*/
{
bool parsing, success;

if (parsetrace)
   puts("starting parser execution");
parsing=true;
do /* while parsing */
   {
   if (parsetrace)
      parsepic();

   /* do case on alphabet of stack top */
   if (is_action(topstack()))
      {
      doaction();
      pop();
      }
   else if (is_nonterm(topstack()))
      {
      userule(&success);  /* to substitute for stack top */
      if (!success)
         {
         puts("reject");
         parsing=false;
         }
      }
   else  /* topstack is a terminal */
      if (ontop(nextinput()))
         {
         if (parsetrace)
            {
            printf("matching:%s\n",tokname);
            increment_num_lines_printed(1);
               /* and prompt to continue if large enough */
            }  /* end if (parsetrace) */
            pop();
            gettok();
            }
      else  /* topstack != nextinput */
         {
         parsing=false;
         if (ontop("%") && athead("#"))
            puts("accept");
         else
            puts("reject");
         }
   }
while (parsing);  /* end do */
} /*  end cycle */
/*************************************************************************/
void userule(bool *successp)
/*
use ll(1) parse action table, encoded procedurally, to either:
1) replace stack top with the right part of a rule and return *successp=true
or 2) to return *successp=false
*/
{
 *successp=true;  /*  will change if necessary */

    /* do case on nonterminal on top of stack */
    if (ontop("goal"))
        replace("program");  /* replace topstack with argument "e" */

    else if (ontop("program"))
    {
        if (athead("$declare") || athead("#") || athead(""))
            replace("decls states");
        else
            *successp=false;

    }

    else if (ontop("decls"))
    {
        if (athead("$declare"))
            replace("decl decls");
        else if (athead(":") || athead("$id") || athead("$put") || 
                athead("$get") || athead("$stop") || athead("$goto") || athead("$if") || athead("$do") || athead(""))
            replace(emptystr);
        else
            *successp=false;

    }

    else if (ontop("states"))
    {
        if (athead(":") || athead("$id") || athead("$put") || athead("$get") || athead("$stop")
                || athead("$goto") || athead("$if") || athead("$do") || athead(""))
            replace("state states");
        else if(athead("#") || athead("") || athead("$end") || athead(";"))
            replace(emptystr);
        else
            *successp=false;
    }

    else if (ontop("decl"))
    {
        if (athead("$declare"))
            replace("$declare idlist");
        else
            *successp=false;

    }

    else if (ontop("idlist")) 
    {
        if (athead("$id"))
            // CHECK EBNF FOR SPACES NEXT TO $int
            replace("$id ( $int ) melist");
        else
            *successp=false;
    }

    else if (ontop("melist")) 
    {
        if (athead(","))
            replace(", $id ( $int ) melist");
        else if (athead("$declare") || athead(""))
        {
            replace(emptystr);
        }
        else
            *successp=false;
    }

    else if (ontop("state")) 
    {
        if (athead(":") || athead(""))
            replace("labelsub ustate");
        else
            *successp=false;
    }
    else if (ontop("labelsub")) 
    {
        if (athead(":"))
            replace("label");
        else if (athead("$id") || athead("$put") || athead("$get") || athead("$stop") || athead("$goto") || athead("$if") || athead("$do") || athead(""))
            replace(emptystr);

        else
            *successp=false;
    }

    else if (ontop("label"))
    {
        if (athead(":"))
            replace(": $id :");
        else
            *successp=false;
    }

    else if (ontop("ustate"))
    {
        if (athead("$id"))
            replace("assign");
        else if (athead("$put"))
            replace("put");
        else if (athead("$get"))
            replace("get");
        else if (athead("$stop"))
            replace("stop");
        else if (athead("$if"))
            replace("if");
        else if (athead("$do"))
            replace("group");
    }

    else if (ontop("assign"))
    {
        if (athead("$id"))
            replace("var = expr ;");
    }

    else if (ontop("put"))
    {
        if (athead("$put"))
            replace("$put exprlist ;");
    }

    else if (ontop("exprlist"))
    {
        if (athead("+") || athead("-") || athead("$int") || athead("$id") || athead("(") || athead(";") || athead(""))
            replace("expr mexprs");
                
    }

    else if (ontop("mexprs")) 
    {
        if (athead(","))
            replace(", expr mexprs");
        else if (athead(";") || athead(""))
            replace(emptystr);
    }

    else if (ontop("get"))
    {
        if (athead("$get"))
            replace("$get varlist ;");
        
    }

    else if (ontop("varlist"))
    {
        if (athead("$id"))
            replace("var mvar");

    }

    else if (ontop("mvar"))
    {
        if (athead(","))
                     replace(", var mvar");

        else if (athead(";") || athead("") )
                          replace(emptystr);
                         
    }

    else if (ontop("stop"))
    {
        if (athead("$stop"))
                     replace("$stop ;");
    }

    else if (ontop("goto"))
    {
        if (athead("$goto"))
                     replace("$goto $id ;");
    }

    else if (ontop("if"))
    {
        if (athead("$if"))
                     replace("$if logexpr $then state");
    }

    else if (ontop("group"))
    {
        if (athead("$do"))
                     replace("$do ; states $end ;");
    }
    
    else if (ontop("logexpr"))
    {
        if (athead("+") || athead("-") || athead("$int") || athead("$id") || athead("(") || athead(""))
            replace("expr relop expr");
        
    }

    else if (ontop("relop"))
    {
        if (athead("< relop"))
            replace("<");

        else if (athead("> relop"))
            replace(">");

        else if (athead("= relop"))
            replace("=");
        else if (athead("+") || athead("-") || athead("$int") || athead("$id") || athead("(") || athead("$then") || athead(":") || athead("$id") || athead("$put") || athead("$get") || athead("$stop") || athead("$goto") || athead("$if") || athead("$do") || athead(""))
            replace(emptystr);
    }

    else if (ontop("expr"))
    {
        if (athead("+") || athead("-") || athead(""))
            replace("plusminsub term plusminterms");
        
    }

    else if (ontop("plusminsub"))
    {
        if (athead("+"))
            replace("+");

        else if (athead("-"))
            replace("-");

        else if (athead("$id") || athead("(") || athead("$int") || athead(""))
            replace(emptystr);
    }

    else if (ontop("plusminterms"))
    {
        if (athead("+"))
            replace("+ term plusminterms");

        else if (athead("-"))
            replace("- term plusminterms");

        else if (athead("#") || athead(""))
            replace(emptystr);
    }

    else if (ontop("term"))
    {
        if (athead("$id") || athead("$int") || athead("("))
            replace("facet muldiv");
    }

    else if (ontop("muldiv"))
    {
        if (athead("*"))
            replace("* fact muldiv");

        else if (athead("/"))
            replace("/ fact muldiv");

        else if (athead("+") || athead("-") || athead(""))
            replace(emptystr);
    }

    else if (ontop("fact"))
    {
        if (athead("$id")) 
            replace("var");

        else if(athead("$int"))
            replace("$int");

        else if (athead("("))
            replace("( expr )");
    }

    else if (ontop("var"))
    {
        if (athead("$id"))
            replace("$id sub");
    }

    else if (ontop("sub"))
    {
        if (athead("("))
            replace("( expr )");

        else if (athead(",") || athead(""))
            replace(emptystr);
    }
   
            else
            {
                printf("bad nonterminal on stack:%s\n",topstack());
                puts("parser done");
                puts("push Enter to leave User Window");
                getchar();
                exit(parse_error);  /* stop parser */


            }
}/* end userule */
/*************************************************************************/
void doaction(void)
/*
do the action associated with stack top
*/
{
/* strparam topstack(), nextinput(); */

/* do case on particular action on top of stack */
if (ontop("1"))
   emit("add");
else if (ontop("2"))
   emit("mult");
else if (ontop("3"))
   {
   emit("lit");
   emit("1");
   emit("ldi");
   }
else
   printf("bad action on stack:%s\n",topstack());
}  /* end doaction */
/*************************************************************************/
void emit(strparam s)
/*
emit s into next word of code memory image
*/
{
if (parsetrace)
   {
   printf(">>>>>>>>>>emitting:%s\n",s);
   increment_num_lines_printed(1);
   }

++pc;
strcpy(code[pc],s);
}  /* end emit */
/*************************************************************************/
void initialize(void)
/*
initialize parser
*/
{
/* open files */
tokfilep=fopen("SelectionSortTokenFile.txt","r");
if (tokfilep==NULL)
   {
   puts("error in trying to open tokfile");
   puts("push Enter to leave User Window");
   getchar();
   exit(1);
   }

codefilep=fopen("codefile","w");
if (codefilep==NULL)
   {
   puts("error in trying to open codefile");
   puts("push Enter to leave User Window");
   getchar();
   exit(1);
   }

datafilep=fopen("datafile","w");
if (datafilep==NULL)
   {
   puts("error in trying to open datafile");
   puts("push Enter to leave User Window");
   getchar();
   exit(1);
   }

/* further initialize input queue */
gettok();  /* initializes tkname and tokvalue */

/* initialize stack */
top=0;
push("%");
push("goal");

pc=0;  /* causes code to be emitted starting at code[1] */
dc=0;

//from now on, send output to a text file rather than screen, if flag set
if(SendOutputToFile)
   {
      outfilep=freopen("parseout.txt", "wt", stdout);
      if(outfilep==NULL)
         printf("error in redirecting stdout to file parseout.txt");
   }
}  /* end initialize */
/*************************************************************************/
void cleanup(void)
/*
do everything that needs to be done right before exiting parser
*/
{
int j;

/* output code memory image to codefile */
for (j=1;j<=pc;++j)
   fprintf(codefilep,"%s\n",code[j]);

/* output data memory image to datafile */
for (j=1;j<=dc;++j)
   fprintf(datafilep,"%d\n",data[j]);
}  /* end cleanup */
/*************************************************************************/
void parsepic(void)
/*
produce a short picture of the state of the parser
*/
{
int j;

/* show stack */
printf("stack=  ");
for (j=top; j>=1; --j)
   printf("%*s ",fw,stack[j]);
puts("");  /* end line */

/* show next token */
printf("tokname=%s    tokvalue=%s\n",tokname,tokvalue);

puts("");

increment_num_lines_printed(3);
   /* and possibly prompt user to continue */

}  /* end parsepic */
/*************************************************************************/
void replace(strparam rightpart)
/*
replace stack top, which should be a nonterminal, with 'rightpart'.
in 'rightpart', whitespace is interpreted as separating distinct symbols of
the right part string.  'rightpart' can be of any length, providing that each
of its component symbols are all no more than STR_SIZE chars.
*/
{
if (parsetrace)
   {
   printf("using rule: %s->%s\n", topstack(), rightpart);
   increment_num_lines_printed(1);
   }

pop();
pushstring(rightpart);
}  /* end replace */
/*************************************************************************/

/*************************************************************************/
void push_substring_as_one_element(
   strparam s,
   int l,
   int r)
/*  push the substring of s from s[l] to s[r] onto parse stack as
one stack element */
{
int j;

++top;
for(j=0; j<smaller_int_of(r-l+1, STR_SIZE); j++)
   stack[top][j]=s[l+j];
stack[top][j]='\0';
}  /* end  push_substring_as_one_element */
/*************************************************************************/

/*************************************************************************/
int smaller_int_of(
   int n,
   int m)
{
return n<m ? n : m;
}
/*************************************************************************/

/*************************************************************************/
void pushstring(strparam rp)
/*
push the symbols in the 'rp' string onto the stack.
in 'rp', whitespace is interpreted as separating distinct symbols of
the string.  'rp' can be of any length, providing that each
of its component symbols are all no more than STR_SIZE chars.
*/
{
int l,r;

r=strlen(rp)-1;  //initialize r to rightmost logical char of rp
for(;;) //ever do
   //push another item onto the parse stack
   {
      if (r==-1)
         return;  //nothing left to push
      
      //set r so rp[r] is rightmost char of rightmost remaining item, if any
      for(;;) //ever do
         if(!isspace(rp[r]))
            break;  //r is now correct
         else if (r==0)
            return;  //nothing left to push
         else
            r--;

      //set l so rp[l] is leftmost char of rightmost remaining item, if any
      l=r;
      while (l>0 && !isspace(rp[l-1]) )
         l--;
            //l is now correct
      
      push_substring_as_one_element(rp, l, r);
         //push substring of rp from rp[l] to rp[r] onto parse
         // stack as one stack element
      r=l-1;  //prepare to look leftwards for next item to push
   }
}  /* end  pushstring */

//-------------------------------------------------------------------

/*************************************************************************/
void pop(void)
/*
pop parser stack
*/
{
--top;
}  /* end pop */
/*************************************************************************/
void push(strparam s)
/*
push s onto parser stack
*/
{
++top;
strcpy(stack[top],s);
}  /* end push */
/*************************************************************************/
bool ontop(strparam s)
/*
returns true iff s on top of parse stack
*/
{
return(eqstr(s,stack[top]));
}  /* end ontop(s) */
/*************************************************************************/
char *topstack(void)
/*
topstack <- (pointer to) string on top of stack
*/
{
return(stack[top]);
}  /* end topstack */
/*************************************************************************/
void gettok(void)
/*
get next token from tokfile
*/
{
fscanf(tokfilep," ");  /* try to read eof */
if (!feof(tokfilep))
   {
   fscanf(tokfilep,"%[^\n]%*c",tokname);
   fscanf(tokfilep,"%[^\n]%*c",tokvalue);
   }
else
   /* set to artificial value meaning 'end of tokfile' */
   {
   strcpy(tokname,"#");
   strcpy(tokvalue,"#");
   }
}  /* end gettok */
/*************************************************************************/
bool athead(strparam s)
/*
returns true iff terminal s is at head of input queue
*/
{
return(eqstr(s,tokname));
}  /* end athead(s) */
/*************************************************************************/
char *nextinput(void)
/*
nextinput <- (pointer to) string at head of input queue
*/
{
return(tokname);
}
/*************************************************************************/
bool is_action(strparam s)
/*
return true iff s is an action symbol
*/
{
return(isdigit(s[0]));
}  /* end is_action */
/*************************************************************************/
bool is_nonterm(strparam s)
/*
return true iff s is a nonterminal symbol
*/
{
return(isalpha(s[0]));
}  /* end is_nonterm */
/*************************************************************************/
bool eqstr(strparam s1, strparam s2)
/*
returns true iff s1=s2 as strings
*/
{
return(!strcmp(s1,s2));
}  /* end eqstr */
/*************************************************************************/
void increment_num_lines_printed(int extra_lines)
/*
add 'extra_lines' to count of number of lines printed since last
prompt.  if it has reached some threshold, prompt user to continue.
this is to give the user a chance read the contents of the User Window
before it disappears.
*/
{
static int num_lines=0;  /* number of trace lines printed since last prompt */
int max_between_prompts=14;

if (SendOutputToFile)
   return;  //no need for any prompts

num_lines+=extra_lines;

/* possibly prompt user to continue */
if (num_lines>=max_between_prompts)
   {
   printf("push Enter to continue");
   getchar();
   puts("************************************************************");
   puts("");
   num_lines=0;
   }
}  /* end increment_num_lines_printed */
/*************************************************************************/

