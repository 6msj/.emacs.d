* Virtual Machines
** Construct the virtual machine simulator which will execute the intermediate language (IL) by the parser.
** Designing the virtual machine is equivalent to specifying the IL.
** Some popular structures are a 3-address machine, a 2-address machine, and a stack machine (ie. a 0-address machine)
** Set of IL operators are virtual machine instructions.
** Data memory segment, you create space for your code.
** The Machine Cycle:
*** running; = true
*** pc: = 0
*** WHILE running DO
**** pc: pc+1
**** Execute instructions in Code[pc]
*** END WHITE
*** stop
* Strings
** The following is machinery for formal reasoning about languages. It is simply a collection of useful definitions.
** An alphabet is a finite set. Each element of an alphabet is a symbol.
** TODO :Write Examples.
** Def: A string over an alphabet is a finite sequence of symbols of the alphabet. The length of a string is the length of the sequence. If alpha is a string, then |alpha| denotes the length of the string.
** Def: Let alpha and beta be strings (over some alphabet). Then the catenation (or concatenation) of alpha and beta, denoted alpha beta (i.e. by just placing the string adjacent), is the catenation of the sequences represented by alpha and beta.
** Def: Let alpha be a string and i a non-negative integer. Then, we define the exponentiation of alpha to the i power, denoted alpha^i as: alpha^0 = e, alpha^n = alpha(alpha^(n-1) or all n>=1)

* CFGS
** defn: A CFG G is said to be LL(1) iff both:
*** 1) G is unambiguous.
*** 2) G has a valid PA set.
**  theorem
*** For a reduced CFG, suppose that for each nonterminal the selection sets for rules for that nontermina are     pairwise disjoint.  Then, the grammar is unambiguous.
* Phrases
* LL Parsing
** The following machines of interest that are based on CFG's:
*** Recognizer inputs a string over T. outputs 'accept' or 'reject' depending on whether the string is a sentence.
*** Parser does the above, and also produces derivations for input strings that are sentences.
*** Translator does the above, and also produces "translations" for input strings that are sentences.
** There are a number of different algorithms that can be used to construct a parser. 
** For Parse Action table, showing rule number for a given non terminal.
** The Parse Action table shows us the parse action set for a given rule for a given nonterminal.
** The numbers in a PA table is the rule number.
** How to get Parse Action Table
** If A -> X, and First(A) is #, then X is Follow(A).
** Before we give the precise definition of First and Follow Sets, we show how to use it in the construction of LL(1) parsing tables.
** Repeat the following two steps for each nonterminal A and each production A -> @:
*** 1. For each token @ in First(@), add A -> @ to the entry M[A, a].
*** 2. If # is in First(@), for each element a of Follow(A) (where a is a token or a is $), add A-> @ to M[A,a].
* LL Tables 1
** A CFG G is said to be reduced iff:
*** 1) For every terminal x: there is some sentence containing x. ("no useless terminals")
*** 2) For every nonterminal X: X is contained in some sentential form, and X derives a non-empty string of terminals. ("no useless non-terminals")
*** 3) For every rule r: removing r from G removes at least one sentence from L(G). ("no useless rules")
** T = { 'x', 'y' }
** N = { S, A }
** S is the start symbol
** p =
*** 1) S-> 'x' A
*** 2) A-> #
*** 3) S->S
*** Note that y is a useless terminal, A is a useless nonterminal, and 3) is a useles rule. So the CFG is not reduced.
  
** defn  Consider the LL(1) Parsing Algorithm with CFG G in its Rule table and with Parse Action table PA.  Suppose that for every string α ∈ T* as input, the algorithm outputs:
*** 1)  'reject', iff α ∉ L(G).
*** 2)  'accept' and a derivation from S to α, iff α ∈ L(G).
*** Then, PA is said to be valid for G.
** defn  Consider the LL(1) Parsing Algorithm with CFG G in its Rule table and with Parse Action table PA.  Suppose that for every string α ∈ T* as input, the algorithm outputs:
*** 1)  'reject', iff α ∉ L(G).
*** 2)  'accept' and a derivation from S to α, iff α ∈ L(G).
*** Then, PA is said to be valid for G.

** defn  Let α ∈ (T  ∪ N)*.  α is said to be nullable iff α =>* ε  .
*** e.g.  Gse3
***    
*** "mf  mt"   is nullable.
*** ε   is nullable.
*** "e"  is not nullable
*** "'+' t mt"   is not nullable
** defn  Let α ∈ (T  ∪ N)*.  first(α) ≡ {x ∈ T | α =>* x ...}  .
*** Note that "..." is shorthand for "any string in (T  ∪ N)*" .  i.e. more technically the above means first(α) ≡ {x ∈ T | there exists a β ∈ (T  ∪ N)* such that α =>* x β }.
*** e.g.  Gse3
*** string	first(string)
*** t mt	{ 'x', '(' }
*** '+' t mt	{ '+' }
*** ε	empty set
*** f mf	{ 'x', '(' }
*** '*' f mf	{ '*' }
*** 'x'	{ 'x' }
*** '(' e ')'	{ '(' }
*** mf '+'	{ '*', '+' }

* LL Tables 2
* PLH Parser
* Translation Schemes
* PLH Constructs
* Scanning
* Bottom UP Parsing
* Code Generation
* Code optimization
* Regular Languages
* Slr Table Construction



