* TODO Find out what makes an LL1 CFG.
** We are making a recognizer. 
** For our project, we will be using the LL(1) parsing algorithm.
** 
* DONE Find out how to find a valid PA set for each rule.
** For each token a in FIrst(@), add A -> @ to then entry M[A,a].
** If # is in First(@), for each element a of FOllow(A) (where a is a token or a is $), add A -> @ to M[A,a]. 
* DONE Figure out what PL/H means.
** Before we can recognize and translate PL/H, we need to define it. 
** File 9, Page 7: Bottom of page, definition for PL/H. 
* TODO Construct an LL1 CFG.
** Steps to construct an LL1 CFG.
*** Not Left Recursive
*** Unambiguous
*** Valid PA set for each rule
*** File 8, pg 9-13:
*** DONE Find Terminal Set
**** T = { * , $declare, $id, (, $int, ), ;, !, :, =, , $put, $get, $stop, $goto, $if, $do, $end, <, >,  -, /,  }
**** N = { program, decl, state, label, ustate, assign, put, get, stop, goto, if, group, logexpr, relop, expr, term, fact, var }
*** EBNF Metasymbols
**** -> - "is"
**** * - 0 or more preceding
**** + - 1 or more preceding
**** & - 1 or more preceding separated by commas
**** ! - optional occurence of preceding
**** | - alternation (i.e. "or")
**** ws (whitespace) - catenation (i.e. placing adjacent with no operator)
**** [] - grouping symbols for above
**** Precedence of Metasymbols
***** [] followed by *+&! followed by catenation followed by | 

*** DONE Prove that the EBNF which is the definition of the PL/H is left recursive first, and thus not an LL1 CFG.
*** TODO Change EBNF To a CFG.
**** program -> decls states
**** decls -> decl decls 
**** decls -> # 
**** states -> state states
**** states -> # 
**** decl -> '$declare' idlist ';'
**** idlist -> ['$id' '('  '$int'  ')' ] melist
**** melist -> ',' ['$id' '('  '$int'  ')' ] melist
**** melist -> #
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
**** 
*** TODO After proving EBNF is not Left Recursive, convert CFG to be not left recursive by either left factoring or eliminating left recursion.
*** TODO Generate A valid PA set for each rule.
**** TODO: Create First and Follow Sets for each rule.
*** TODO Import the CFG and PA sets into Parse.cpp so as to create a recognizer for PL/H.
*** TODO Test this recognizer by taking TokeFile.txt to be SelectionSortTokeFile.txt and running your recognizer with ParseTrace and SendOutputToFile both on.






