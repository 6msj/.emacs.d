;;;; -*- lexical-binding: t; -*-

(use-package magit
  ;; If on Bash For Windows (or Ubuntu), probably need to install a later
  ;; version of git.
  ;; https://askubuntu.com/questions/500090/upgrading-to-the-last-version-of-git-from-the-source-repository-or-ppa
  ;; sudo apt-get install python-software-properties
  ;; sudo add-apt-repository ppa:git-core/ppa
  ;; sudo apt-get update
  ;; sudo apt-get install git
  :ensure t
  :commands (magit-toplevel
             magit-status
             magit-blame
             magit-log
             magit-find-file
             magit-find-file-other-window)
  :config
  (setq magit-rebase-arguments '("--autostash"))
  (setq magit-diff-refine-hunk 'all)
  (defun +magit-mbox-apply-git-patch ()
    "Use `magit' to apply patch generated by `+mbox-open-notmuch-messages'."
    (interactive)
    (magit-run-git-async "am" (expand-file-name "~/.tmp-mbox")))

  (defun +magit-git-amend-reset-commit-date ()
    "Amend commit and reset commit date."
    (interactive)
    (magit-run-git-async "commit" "--amend" "--no-edit" "--date=now"))

  (defun +magit-git-submodule-update--init--recursive ()
    "Run $ git submodule update --init --recursive."
    (interactive)
    (magit-run-git-async "submodule" "update" "--init" "--recursive"))

  (magit-define-popup-action
    'magit-submodule-popup ?U
    "Update Init Recursive"
    #'+magit-git-submodule-update--init--recursive)

  (setq magit-bury-buffer-function 'magit-mode-quit-window)

  (add-hook 'git-rebase-mode-hook
            (lambda ()
              (local-set-key (kbd "g") nil)))
  (with-eval-after-load 'evil
    (evil-define-key 'normal git-rebase-mode-map
      (kbd "gr") 'revert-buffer
      (kbd "g") nil)
    (evil-define-key 'normal magit-refs-mode-map
      (kbd "`") 'magit-process-buffer
      (kbd "$") 'evil-end-of-line)
    (evil-define-key 'normal magit-process-mode-map
      (kbd "`") 'quit-window)
    (evil-define-key 'normal magit-revision-mode-map
      (kbd "q") 'magit-mode-bury-buffer
      (kbd "$") 'evil-end-of-line)
    (evil-define-key 'normal magit-log-mode-map
      (kbd "q") 'magit-log-bury-buffer
      (kbd "`") 'magit-process-buffer
      (kbd "~") 'magit-diff-default-context
      (kbd "0") 'evil-digit-argument-or-evil-beginning-of-line
      (kbd "$") 'evil-end-of-line)
    (evil-define-key 'normal magit-status-mode-map
      (kbd "q") 'magit-mode-bury-buffer
      (kbd "`") 'magit-process-buffer
      (kbd "~") 'magit-diff-default-context
      (kbd "0") 'evil-digit-argument-or-evil-beginning-of-line
      (kbd "$") 'evil-end-of-line
      (kbd "Q") 'delete-window)
    (evil-define-key 'normal magit-repolist-mode-map
      (kbd "q") 'magit-mode-bury-buffer
      (kbd "Q") 'delete-window
      (kbd "RET") 'magit-repolist-status
      (kbd "gr") 'magit-list-repositories))

  ;; Save buffers automatically instead of asking.
  (setq magit-save-repository-buffers 'dontask)

  (setq magit-repository-directories '("~/Developer"
                                       "~/Code"
                                       "~/.emacs.d"
                                       "~/.vim"
                                       "~/.dotfiles"
                                       "~/.zsh"))
  (setq magit-refresh-status-buffer nil)

  (defadvice magit-show-commit (around dont-select-commit-window activate)
    "magit-show-commit selects the window it opens unless magit-display-buffer-noselect is set.
Setting magit-display-buffer-noselect changes the selection logic for other parts of magit though.
Instead, advise magit-show-commit by setting magit-show-commit to t
before calling magit-show-commit and set it back to nil afterwards."
    (setq magit-display-buffer-noselect t)
    (setq ad-return-value ad-do-it)
    (setq magit-display-buffer-noselect nil))

  ;; https://github.com/magit/magit/issues/2541 (tweaked)
  (defun +magit-display-buffer-function (buffer)
    "Display buffer in another window if single window or special magit mode."
    (display-buffer
     buffer
     (cond
      ((eq (count-windows) 1)
       nil)
      ((and (derived-mode-p 'magit-mode)
            (eq (with-current-buffer buffer major-mode)
                'magit-status-mode))
       nil)
      ((memq (with-current-buffer buffer major-mode)
             '(magit-process-mode
               magit-revision-mode
               magit-diff-mode
               magit-stash-mode))
       nil)
      (t
       '(display-buffer-same-window)))))
  (setq magit-display-buffer-function #'+magit-display-buffer-function)

  ;; Add rebase argument to pull
  ;; https://github.com/magit/magit/issues/2597
  (magit-define-popup-switch 'magit-pull-popup ?R "Rebase" "--rebase")

  (setq magit-bisect-show-graph t)

  (defun +magit-submodule-remove (path &optional leave-in-work-tree)
    "Remove the submodule at PATH.

https://stackoverflow.com/questions/1260748/how-do-i-remove-a-submodule"
    (interactive
     (list (magit-completing-read "Remove module" (magit-get-submodules)
                                  nil t nil nil (magit-section-when module))))
    (magit-with-toplevel
      ;; 0. mv a/submodule a/submodule_tmp
      (shell-command (format "mv %s %s_tmp" path path))

      ;; 1. git submodule deinit -f -- a/submodule
      (magit-run-git "submodule" "deinit" "-f" "--" path)

      ;; 2. rm -rf .git/modules/a/submodule
      (shell-command (format "rm -rf .git/modules/%s" path))

      (if (not leave-in-work-tree)
          ;; 3. git rm -f a/submodule
          (magit-run-git "rm" "-f" path)
        ;; # If you want to leave it in your working tree and have done step 0.
        ;; 3b. git rm --cached a/submodule
        ;; 3b. mv a/submodule_tmp a/submodule
        (magit-run-git "rm" "--cached" path)
        (shell-command-to-string (format "mv %s_tmp %s" path path)))))

  (magit-define-popup-action
    'magit-submodule-popup ?x "Remove" #'+magit-submodule-remove)

  (defun +magit-branch-and-checkout-and-squash-all-commits (branch
                                                            start-point
                                                            &optional args)
    "Create and checkout BRANCH at branch or revision START-POINT and squash all\
 commits on the new branch.

Check out `magit-branch-and-checkout'.

https://stackoverflow.com/questions/1657017/how-to-squash-all-git-commits-into-one"
    (interactive (magit-branch-read-args
                  "Create and checkout branch squashing all commits"))
    (if (string-match-p "^stash@{[0-9]+}$" start-point)
        (magit-run-git "stash" "branch" branch start-point)
      (magit-call-git "checkout" args "-b" branch start-point)
      (magit-branch-maybe-adjust-upstream branch start-point)
      (shell-command "git reset $(git commit-tree HEAD^{tree} -m \"2017\")")
      (magit-refresh)))

  ;;; Improve Bisect

  ;; Clear bisect variables on these hooks
  (add-hook 'magit-status-mode-hook #'+magit-bisect-reset-state)
  (add-hook 'magit-log-mode-hook #'+magit-bisect-reset-state)

  (defvar +magit-bad-revision nil "The bad revision to use in git bisect")
  (defvar +magit-good-revision nil "The good revision to use in git bisect")

  (defun +magit-bisect-mark-commit (revision good)
    "Mark a commit for bisecting.

REVISION: The commit to mark.
GOOD: If this is true, commit is marked as good, else bad."
    (if good
        (setq +magit-good-revision revision)
      (setq +magit-bad-revision revision))
    (+magit-bisect-remove-popup-actions)
    (+magit-add-bisect-mark-popup-actions))

  (defun +magit-bisect-mark-bad-commit (revision)
    "Mark REVISION as bad for bisecting."
    (interactive (list (magit-read-other-branch-or-commit "Mark bad commit")))
    (+magit-bisect-mark-commit revision nil))

  (defun +magit-bisect-mark-good-commit (revision)
    "Mark REVISION as good for bisecting."
    (interactive (list (magit-read-other-branch-or-commit "Mark good commit")))
    (+magit-bisect-mark-commit revision t))

  (defun +magit-bisect-reset-state ()
    "Reset bad and good git bisect variables."
    (interactive)
    (+magit-bisect-remove-popup-actions)
    (setq +magit-good-revision nil)
    (setq +magit-bad-revision nil)
    (+magit-add-bisect-mark-popup-actions))

  (defun +magit-bisect-remove-popup-actions ()
    "Remove popup actions to select bad and good commits."
    (magit-remove-popup-key 'magit-bisect-popup :action ?X)
    (magit-remove-popup-key 'magit-bisect-popup :action ?Z)
    (when (and +magit-good-revision +magit-bad-revision)
      (magit-remove-popup-key 'magit-bisect-popup :action ?C)))

  (defun +magit-add-bisect-mark-popup-actions ()
    "Add popup actions to select bad and good commits."
    (let ((bad-str (if +magit-bad-revision
                       (concat "Marked bad commit: " +magit-bad-revision)
                     "Mark bad commit"))
          (good-str (if +magit-good-revision
                        (concat "Marked good commit: " +magit-good-revision)
                      "Mark good commit")))
      (magit-define-popup-action
        'magit-bisect-popup ?X bad-str #'+magit-bisect-mark-bad-commit)
      (magit-define-popup-action
        'magit-bisect-popup ?Z good-str #'+magit-bisect-mark-good-commit)
      (when (and +magit-good-revision +magit-bad-revision)
        (magit-define-popup-action 'magit-bisect-popup
          ?C
          (format "Start: Bad commit: %s - Good Commit: %s"
                  +magit-bad-revision +magit-good-revision)
          #'+magit-bisect-with-good-bad-commits))))

  (defun +magit-bisect-with-good-bad-commits ()
    "Run magit-bisect with `+magit-bad-revision' and `+magit-good-revision'"
    (interactive)
    (magit-bisect-start +magit-bad-revision +magit-good-revision))

  (+magit-add-bisect-mark-popup-actions))

(use-package smerge-mode
  :ensure nil
  :commands (smerge-start-session)
  :config
  (when (< emacs-major-version 26)
    (defalias 'smerge-keep-upper 'smerge-keep-mine)
    (defalias 'smerge-keep-lower 'smerge-keep-other)))

(use-package p4
  :ensure t
  :commands (;; p4-group
             ;; p4-groups
             ;; p4-jobspec
             ;; p4-lock
             ;; p4-login
             ;; p4-logout
             ;; p4-passwd
             ;; p4-set
             ;; p4-shelve
             ;; p4-sync --> p4-get
             ;; p4-tickets
             ;; p4-unlock
             ;; p4-unshelve
             p4-add
             p4-branch
             p4-branches
             p4-client
             p4-changes
             p4-diff2
             p4-describe
             p4-edit
             p4-reopen
             p4-depot-find-file
             p4-filelog
             p4-files
             p4-fixes
             p4-flush
             p4-fstat
             p4-get-client-name
             p4-grep
             p4-update
             p4-help
             p4-have
             p4-info
             p4-integ
             p4-job
             p4-jobs
             p4-label
             p4-labels
             p4-labelsync
             p4-move
             p4-opened
             p4-print
             p4-set-p4-port
             p4-revert
             p4-refresh
             p4-resolve
             p4-status
             p4-submit
             p4-toggle-vc-mode
             p4-user
             p4-users
             p4-version
             p4-annotate
             p4-where
             p4-delete
             p4-fix
             p4-reconcile
             p4-diff
             p4-diff-all-opened
             p4-ediff)
  :config
  (setq p4-executable "~/.bin/p4"))

(provide 'jn-git)
;; Local Variables:
;; byte-compile-warnings: (not free-vars unresolved noruntime cl-functions)
;; End:
;;; jn-git.el ends here
